import { Observable } from 'rxjs';
import { EventEmitter } from '@angular/core';

import { AsyncValidatorFn, JoiSchema, JoiError } from '../interfaces/Validator';
import { FormGroup } from '../models/FormGroup';


import _ from 'lodash';
import {
  AbstractControlOptions,
  AbstractControlState,
  FormArrayState,
  FormControlState,
  FormGroupState
} from '../interfaces/Form';

import { FormArray } from './FormArray';

/**
 * This is the base class for `FormControl`, `FormGroup.ts`, and `FormArray`.
 *
 * It provides some of the shared behavior that all controls and groups of controls have, like
 * running validators, calculating status, and resetting state. It also defines the properties
 * that are shared between all sub-classes, like `value`, `valid`, and `dirty`. It shouldn't be
 * instantiated directly.
 *
 *
 * @publicApi
 */
export abstract class AbstractControl {

  /** @internal */
  public readonly pendingValue: any;

  /**
   * The current value of the control.
   *
   * * For a `FormControl`, the current value.
   * * For a `FormGroup`, the values of enabled controls as an object with a key-value pair for each member of the group.
   * * For a `FormArray`, the values of enabled controls as an array.
   *
   */
  public readonly value: any;

  /**
   * An object containing any errors generated by failing validation,
   * or null if there are no errors.
   */
  public readonly errors: JoiError[] | null;


  /**
   * A Joi object schema
   */
  // public readonly schema: JoiSchema | null;

  /**
   * True if the control is marked as `touched`.
   *
   * A control is marked `touched` once the user has triggered
   * a `blur` event on it.
   */
  public readonly touched: boolean = false;

  /**
   * A control is `pristine` if the user has not yet changed the value in the UI.
   *
   * @returns True if the user has not yet changed the value in the UI; compare `dirty`.
   * Programmatic changes to a control's value do not mark it dirty.
   */
  public readonly pristine: boolean = true;

  /**
   * The validation status of the control. There are four possible
   * validation status values:
   *
   * * **VALID**: This control has passed all validation checks.
   * * **INVALID**: This control has failed at least one validation check.
   * * **PENDING**: This control is in the midst of conducting a validation check.
   * * **DISABLED**: This control is exempt from validation checks.
   *
   * These status values are mutually exclusive, so a control cannot be both valid AND invalid or invalid AND disabled.
   */
  public readonly status: string;


  public readonly asyncValidator: AsyncValidatorFn | null;

  public runAsyncValidator: Function;

  public _asyncValidationSubscription: any;

  private _parent: FormGroup | FormArray;

  private _root: FormGroup;

  private _name: string;

  private _path: string[];

  private _initialOptions: AbstractControlOptions | null;

  /**
   *
   * @param controls A collection of child controls. The key for each child is the name
   * under which it is registered.
   *
   */

  public readonly controls: FormGroupState | FormArrayState;

  /**
   * @description
   * Emits an event when the form submission has been triggered.
   */


  /**
   * A multicasting observable that emits an event every time the value of the control changes, in
   * the UI or programmatically.
   */
  public readonly valueChanges: Observable<any>;

  /**
   * A multicasting observable that emits an event every time the validation `status` of the control
   * recalculates.
   */
  public readonly statusChanges: Observable<any>;

  /**
   * Initialize the AbstractControl instance.
   *
   * @param options
   *
   */
  constructor(public state: AbstractControlState | null, private _options: AbstractControlOptions | null) {

    this._storeInitialOptions(_options);
    this.runAsyncValidator = () => {
    };
  }

  get schema(): JoiSchema | null {
    if (this.parent && this.parent.schema) {
      const extractChild = _.find(this.parent.schema['_inner'].children, ['key', this.name]);

      return extractChild ? extractChild.schema : null;
    }



    return this._getControlSchema();
  }

  /** @internal */
  _getControlSchema = () => {
    return null;
  };


  get path(): string[] {
    return this.parent ? [...this.parent.path, this.name] : [];
  }

  get name(): string {
    return this._name;
  }

  set name(name: string) {
    this._name = name;
  }

  /**
   * The parent control.
   */
  get parent(): FormGroup | FormArray {
    return this._parent;
  }

  get root(): FormGroup {
    return this._root;
  }

  get options(): AbstractControlOptions {

    let parentConfig;

    if (this.parent && this.parent.options) parentConfig = {
      ...this.parent.options
    };

    return {
      ...parentConfig,
      ...this._initialOptions
    } || null;
  }

  set options(newConfig: AbstractControlOptions) {

    this._options = {
      ...this._options,
      ...newConfig
    };

    this.updateValueAndValidity({ emitEvent: true });

  }

  /**
   * A control is `enabled` as long as its `status` is not `DISABLED`.
   *
   * @see `status`
   *
   * @returns True if the control has any status other than 'DISABLED',
   * false if the status is 'DISABLED'.
   *
   */
  get enabled(): boolean {
    return this.status !== DISABLED;
  }

  /**
   * A control is `disabled` when its `status` is `DISABLED`.
   *
   * @see `status`
   *
   * Disabled controls are exempt from validation checks and
   * are not included in the aggregate value of their ancestor
   * controls.
   *
   * @returns True if the control is disabled, false otherwise.
   */
  get disabled(): boolean {
    return this.status === DISABLED;
  }

  /**
   * A control is `valid` when its `status` is `VALID`.
   *
   * @see `status`
   *
   * @returns True if the control has passed all of its validation tests,
   * false otherwise.
   */
  get valid(): boolean {
    return this.status === VALID;
  }

  /**
   * A control is `invalid` when its `status` is `INVALID`.
   *
   * @see `status`
   *
   * @returns True if this control has failed one or more of its validation checks,
   * false otherwise.
   */
  get invalid(): boolean {
    return this.status === INVALID;
  }

  /**
   * A control is `pending` when its `status` is `PENDING`.
   *
   * @see `status`
   *
   * @returns True if this control is in the process of conducting a validation check,
   * false otherwise.
   */
  get pending(): boolean {
    return this.status === PENDING;
  }

  /**
   * A control is `dirty` if the user has changed the value
   * in the UI.
   *
   * @returns True if the user has changed the value of this control in the UI; compare `pristine`.
   * Programmatic changes to a control's value do not mark it dirty.
   */
  get dirty(): boolean {
    return !this.pristine;
  }


  /**
   * Marks the control as `touched`. A control is touched by focus and
   * blur events that do not change the value; compare `markAsDirty`;
   *
   *  @param opts options options that determine how the control propagates changes
   * and emits events events after marking is applied.
   * * `onlySelf`: When true, mark only this control. When false or not supplied,
   * marks all direct ancestors. Default is false.
   */
  markAsTouched(): void {
    (this as { touched: boolean }).touched = true;

    this.updateValueAndValidity({ onlySelf: true });
  }

  /**
   * Marks the control as `untouched`.
   *
   * If the control has any children, also marks all children as `untouched`
   * and recalculates the `touched` status of all parent controls.
   *
   *  @param opts options options that determine how the control propagates changes
   * and emits events after the marking is applied.
   * * `onlySelf`: When true, mark only this control. When false or not supplied,
   * marks all direct ancestors. Default is false.
   */
  markAsUntouched(opts: { onlySelf?: boolean } = {}): void {
    (this as { touched: boolean }).touched = false;
  }

  /**
   * Marks the control as `dirty`. A control becomes dirty when
   * the control's value is changed through the UI; compare `markAsTouched`.
   *
   *  @param opts options options that determine how the control propagates changes
   * and emits events after marking is applied.
   * * `onlySelf`: When true, mark only this control. When false or not supplied,
   * marks all direct ancestors. Default is false.
   */
  markAsDirty(opts: { onlySelf?: boolean } = {}): void {
    (this as { pristine: boolean }).pristine = false;
  }

  /**
   * Marks the control as `pristine`.
   *
   * If the control has any children, marks all children as `pristine`,
   * and recalculates the `pristine` status of all parent
   * controls.
   *
   *  @param opts options options that determine how the control emits events after
   * marking is applied.
   * * `onlySelf`: When true, mark only this control. When false or not supplied,
   * marks all direct ancestors. Default is false..
   */
  markAsPristine(opts: { onlySelf?: boolean } = {}): void {
    (this as { pristine: boolean }).pristine = true;
  }

  /**
   * Sets options on a form control .
   *
   * Calling `setOptions` also updates the validity of the parent control.
   *
   * @usageNotes
   * ### Manually set the options for a control
   *
   * ```
   * const login = new FormControl('someLogin');
   * login.setErrors({
   *   notUnique: true
   * });
   *
   * expect(login.valid).toEqual(false);
   * expect(login.errors).toEqual({ notUnique: true });
   *
   * login.setValue('someOtherLogin');
   *
   * expect(login.valid).toEqual(true);
   * ```
   */
  setOptions(options: AbstractControlOptions | null, opts: { emitEvent?: boolean } = {}): void {
    this._initialOptions = options;
    this._updateControlsOptions(opts.emitEvent !== false);
  }


  /**
   * Sets errors on a form control when running validations manually, rather than automatically.
   *
   * Calling `setErrors` also updates the validity of the parent control.
   *
   * @usageNotes
   * ### Manually set the errors for a control
   *
   * ```
   * const login = new FormControl('someLogin');
   * login.setErrors({
   *   notUnique: true
   * });
   *
   * expect(login.valid).toEqual(false);
   * expect(login.errors).toEqual({ notUnique: true });
   *
   * login.setValue('someOtherLogin');
   *
   * expect(login.valid).toEqual(true);
   * ```
   */
  setErrors(errors: JoiError[] | null, opts: { emitEvent?: boolean } = {}): void {
    (this as { errors: JoiError[] | null }).errors = errors;
    this._updateControlsErrors(opts.emitEvent !== false);
  }

  //
  /**
   * @param parent Sets the parent of the control
   */
  setParent(parent: FormGroup | FormArray): void {
    this._parent = parent;
  }

  /**
   * @param root Sets the root of the form
   */
  setRoot(root: FormGroup): void {
    this._root = root;
  }

  updateOptions(options: AbstractControlOptions | null, opts: { emitEvent?: boolean } = {}): void {
    this._initialOptions = {
      ...this._initialOptions,
      ...options
    };
    this._updateControlsOptions(opts.emitEvent !== false);
  }


  /**
   * Recalculates the value and validation status of the control.
   *
   * By default, it also updates the value and validity of its ancestors.
   *
   * @param opts options options determine how the control propagates changes and emits events
   * after updates and validity checks are applied.
   * * `onlySelf`: When true, only update this control. When false or not supplied,
   * update all direct ancestors. Default is false..
   * * `emitEvent`: When true or not supplied (the default), emit the `valueChanges` event
   * observables emit events with the latest status and value when the control is updated.
   * When false, no events are emitted.
   */
  updateValueAndValidity(opts: { onlySelf?: boolean, emitEvent?: boolean } = {}): void {
    this._setInitialStatus();
    this._updateValue();
    if (this.enabled) {
      this._cancelExistingSubscription();
      (<{ errors: JoiError[] | null }>this).errors = this._runJoiValidation();
      (<{ status: string }>this).status = this._calculateStatus();

      if (this.status === VALID || this.status === PENDING) {
        this.runAsyncValidator(opts.emitEvent);
      }

    }


    if (opts.emitEvent !== false) {
      (this.valueChanges as EventEmitter<any>).emit(this.value);
      (this.statusChanges as EventEmitter<any>).emit(this.status);
    }

    if (this._parent && !opts.onlySelf) {
      this._parent.updateValueAndValidity(opts);
    }

  }


  /** @internal */
  private _calculateStatus(): string {
    if (this._allControlsDisabled()) return DISABLED;
    if (this.errors) return INVALID;
    if (this._anyControlsHaveStatus(INVALID)) return INVALID;
    if (this._anyControlsHaveStatus(PENDING)) return PENDING;
    return VALID;
  }

  /** @internal */
  _runJoiValidation() {
    return null;
  }


  /** @internal */
  _updateChildError = (errors: JoiError[]) => {
  };


  private _cancelExistingSubscription(): void {
    if (this._asyncValidationSubscription) {
      this._asyncValidationSubscription.unsubscribe();
    }
  }

  private _setInitialStatus() {
    (this as { status: string }).status = this._allControlsDisabled() ? DISABLED : VALID;
  }

  private _storeInitialOptions = (options: AbstractControlOptions | null) => {
    this._initialOptions = options;
  };


  /** @internal */
  _updateValue(): void {

  }

  /** @internal */
  _isNotExcluded = (c: AbstractControl): Boolean => {

    return !_.get(c.options, 'excluded') && !(_.has(this.options, ['nullExclusion']) && !c.value);

  };

  /** @internal */
  _initObservables() {
    (this as { valueChanges: Observable<any> }).valueChanges = new EventEmitter();
    (this as { statusChanges: Observable<any> }).statusChanges = new EventEmitter();
  }

  /** @internal */
  _initValidators() {
    (<AbstractControl>this).runAsyncValidator = _.debounce((emitEvent?: boolean) => {

      if (this.asyncValidator) {
        (this as { status: string }).status = PENDING;
        const obs = this.asyncValidator(this);
        // this._asyncValidationSubscription =
        // obs.subscribe((errors: JoiError[] | null) => {
        //   if ((this.touched || this.dirty) && this.value) {
        //     (this as { status: string }).status = INVALID;
        //     this.setErrors(errors, { emitEvent });
        //   }
        // });
      }
    }, 500);
  }

  /** @internal */
  _updateControlsOptions(emitEvent: boolean): void {
    (this as { status: string }).status = this._calculateStatus();

    if (emitEvent) {
      (this.statusChanges as EventEmitter<string>).emit(this.status);
    }
  }

  /** @internal */
  _updateControlsErrors(emitEvent: boolean): void {
    (this as { status: string }).status = this._calculateStatus();

    if (emitEvent) {
      (this.statusChanges as EventEmitter<string>).emit(this.status);
    }

    if (this._parent) {
      this._parent._updateControlsErrors(emitEvent);
    }
  }


  /**
   * Sets the value of the control. Abstract method (implemented in sub-classes).
   */
  abstract setValue(value: any, options?: Object): void;

  /**
   * Resets the control. Abstract method (implemented in sub-classes).
   */
  abstract reset(value?: any, options?: Object): void;

  /**
   * Clear the control. Abstract method (implemented in sub-classes).
   */
  abstract clear(options?: Object): void;

  /** @internal */
  abstract _allControlsDisabled(): boolean;

  /** @internal */
  abstract _anyControlsHaveStatus(status: string): boolean
}


/**
 * Reports that a FormControl is valid, meaning that no errors exist in the input value.
 *
 * @see `status`
 */
export const VALID = 'VALID';

/**
 * Reports that a FormControl is invalid, meaning that an error exists in the input value.
 *
 * @see `status`
 */
export const INVALID = 'INVALID';

/**
 * Reports that a FormControl is pending, meaning that that async validation is occurring and
 * errors are not yet available for the input value.
 *
 * @see `markAsPending`
 * @see `status`
 */
export const PENDING = 'PENDING';

/**
 * Reports that a FormControl is disabled, meaning that the control is exempt from ancestor
 * calculations of validity or value.
 *
 * @see `markAsDisabled`
 * @see `status`
 */
export const DISABLED = 'DISABLED';

export type FormHooks = 'change' | 'blur' | 'submit';
